---
title: "A mixed model approach to study human growth trajectories (working title)"
author: "An-Di Yim, Libby Cowgill, David C. Katz, Charles C Roseman"
output:
  rmarkdown::github_document
  html_document:
    toc: yes
    toc_depth: '2'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Set up

```{r set up, results='hide'}

fullpath <- dirname(rstudioapi::getSourceEditorContext()$path)
setwd(file.path(fullpath, "Data"))
library(MASS)
```

# Get climatic variables with WorldClim and PaleoClim

First, get climatic variables from WorldClim database:

```{r worldClim}
library(raster)
library(rgdal)

# For contemporary climatic variables, download WorldClim 
# Use var = "bio" to download bioclimatic variables
current <- getData('worldclim', var='bio', res = 2.5)

# I only want annual mean temp. (1), max temp. of warmest month (5), and min temp. of coldest month (6)
current <- current[[c(1, 5, 6)]]

# Check raster layers were extracted correctly
plot(current)

# Get latitudes and longitudes of different populatios 
# The following coordinates correspod to: Denmark, France, South Africa, Taiwan, and United States

lats <- c("55.674", "43.297", "-33.954", "25.033", "35.087")
lons <- c("12.570", "5.381", "18.488", "121.517", "-106.617")

lats <- as.numeric(lats)
lons <- as.numeric(lons)
coords <- data.frame(x=lons,y=lats)

# Extract data point from raster layers
points <- SpatialPoints(coords, proj4string = current@crs)

values <- extract(current, points)

contemporary.climate <- cbind.data.frame(coordinates(points),values)

# And these are the temporature readings in degree Celcius:
matrix(c(contemporary.climate$bio1/10,
         contemporary.climate$bio5/10,
         contemporary.climate$bio6/10), nrow = 3, ncol = 5, byrow = TRUE,
         dimnames = list(c("Annual Temp.", "Warmest Temp.", "Coldest Temp."), 
                         c("Denmark", "France", "South Africa", "Taiwan", "United States (New Mexico)")))

```

Then, get climatic variables from PaleoClim database:

```{r PaleoClim}
# This data is available for download at: http://www.paleoclim.org/

# Mid-Holocene bioclimatic variable layers
MH_raster <- stack(list.files(path = file.path(fullpath, "Data/Mid_Holocene"), full.names = TRUE, pattern = ".tif")[seq(1, 95, by =5)])

# Late Holocene bioclimatic variable layers
LH_raster <- stack(list.files(path = file.path(fullpath, "Data/Late_Holocene"), full.names = TRUE, pattern = "tif")[seq(1, 95, by =5)])

# Only want bioclimatic variables 1, 5 and 6
MH_raster <- MH_raster[[c(1, 15, 16)]]
LH_raster <- LH_raster[[c(1, 15, 16)]]

par(mfrow = c(2, 1))
plot(MH_raster)
plot(LH_raster)

# Get latitudes and longitudes of past populations
# The following populations were mid-Holocene: Amerindians and Indian Knoll
MHlats <- c("40.80", "37.268")
MHlons <- c("-123.80", "-86.984")

MHlats <- as.numeric(MHlats)
MHlons <- as.numeric(MHlons)

# The rest of past populations were from late Holocene
# Amerindians also cross over to late Holocene
# So the following are: Amerindians, Kulubnarti, Mistihalj, Dart, Luis Lopes, and Point Hope
LHlats <- c("40.80", "21.070", "43.704", "-26.188", "38.717", "68.341")
LHlons <- c("-123.80", "30.665", "19.396", "28.025", "-9.133", "-166.758")

LHlats <- as.numeric(LHlats)
LHlons <- as.numeric(LHlons)

MH.coords <- data.frame(x=MHlons, y=MHlats)
LH.coords <- data.frame(x=LHlons, y=LHlats)

# Repeat the same process as WorldClim data
MH.points <- SpatialPoints(MH.coords, proj4string = MH_raster@crs)
LH.points <- SpatialPoints(LH.coords, proj4string = LH_raster@crs)

MH.values <- extract(MH_raster, MH.points)
LH.values <- extract(LH_raster, LH.points)

MH <- cbind.data.frame(coordinates(MH.points), MH.values)
LH <- cbind.data.frame(coordinates(LH.points), LH.values)

# And these are the temporature readings in degree Celcius:
# For mid-Holocene:
matrix(c(MH$bio_1/10,
         MH$bio_5/10,
         MH$bio_6/10), nrow = 3, ncol = 2, byrow = TRUE,
         dimnames = list(c("Annual Temp.", "Warmest Temp.", "Coldest Temp."), 
                         c("Amerindians", "Indian Knoll")))

# For late Holocene:
matrix(c(LH$bio_1/10,
         LH$bio_5/10,
         LH$bio_6/10), nrow = 3, ncol = 6, byrow = TRUE,
         dimnames = list(c("Annual Temp.", "Warmest Temp.", "Coldest Temp."), 
                         c("Amerindians", "Kulubnarti", "Mistihalj", "Dart", "Luis Lopes", "Point Hope")))

```

# Import data set 

```{r Import dataset}

archae_data <- read.csv("Cowgill_metrics.csv", header = TRUE, na.strings = c("", " ", "NA"))
archae_data <- archae_data[1:556,1:47]

# Get each variable into its proper data type
archae_data$Sample <- as.character(archae_data$Sample)
# Consider Kulubnarti R and Kulubnarti S to be the same population (considering the temporal scale of this project)
# Renmae both Kulubnarti
archae_data[archae_data$Sample == "Kulubnarti S"|archae_data$Sample == "Kulubnarti R",1] <- "Kulubnarti"
# Sample is a facotr
archae_data$Sample <- as.factor(archae_data$Sample)

```

And each measurment is a numeric variable. Here I clean up the humerus first, the follwing steps were perfomed:
- Combine left and right measurement into one single column (prioritize measurements on the left side)
- Setting the values to be numeric variable.

```{r clean up humerus measurments}

for (i in 1:nrow(archae_data)) {
  if (is.na(archae_data$L_Hum_L[i]) == FALSE){
    archae_data$Hum_L[i] <- archae_data$L_Hum_L[i]
    
  }
  else if (is.na(archae_data$L_Hum_L[i]) == TRUE & is.na(archae_data$R_Hum_L[i]) == FALSE){
    archae_data$Hum_L[i] <- archae_data$R_Hum_L[i]
    
  }
  else {
    archae_data$Hum_L[i] <- NA
  } 
}

for (i in 1:nrow(archae_data)) {
  if (is.na(archae_data$L_Hum_AP_Midshaft_D[i]) == FALSE){
    archae_data$Hum_AP_Midshaft_D[i] <- archae_data$L_Hum_AP_Midshaft_D[i]
    
  }
  else if (is.na(archae_data$L_Hum_AP_Midshaft_D[i]) == TRUE & is.na(archae_data$R_Hum_Midshaft_AP_D[i]) == FALSE){
    archae_data$Hum_AP_Midshaft_D[i] <- archae_data$R_Hum_Midshaft_AP_D[i]
    
  }
  else {
    archae_data$Hum_AP_Midshaft_D[i] <- NA
  } 
}

for (i in 1:nrow(archae_data)) {
  if (is.na(archae_data$L_Hum_ML_Midshaft_D[i]) == FALSE){
    archae_data$Hum_ML_Midshaft_D[i] <- archae_data$L_Hum_ML_Midshaft_D[i]
    
  }
  else if (is.na(archae_data$L_Hum_ML_Midshaft_D[i]) == TRUE & is.na(archae_data$R_Hum_Midshaft_ML_D[i]) == FALSE){
    archae_data$Hum_ML_Midshaft_D[i] <- archae_data$R_Hum_Midshaft_ML_D[i]
    
  }
  else {
    archae_data$Hum_ML_Midshaft_D[i] <- NA
  } 
}


for (i in 1:nrow(archae_data)) {
  if (is.na(archae_data$L_Hum_Max_L[i]) == FALSE){
    archae_data$Hum_Max_L[i] <- archae_data$Hum_Max_L[i]
    
  }
  else if (is.na(archae_data$L_Hum_Max_L[i]) == TRUE & is.na(archae_data$R_Hum_Max_L[i]) == FALSE){
    archae_data$Hum_Max_L[i] <- archae_data$R_Hum_Max_L[i]
    
  }
  else {
    archae_data$Hum_Max_L[i] <- NA
  } 
}

for (i in 1:nrow(archae_data)) {
  if (is.na(archae_data$L_Max_Hum_Head_D[i]) == FALSE){
    archae_data$Max_Hum_Head_D[i] <- archae_data$L_Max_Hum_Head_D[i]
    
  }
  else if (is.na(archae_data$L_Max_Hum_Head_D[i]) == TRUE & is.na(archae_data$R_Max_Hum_Head_D[i]) == FALSE){
    archae_data$Max_Hum_Head_D[i] <- archae_data$R_Max_Hum_Head_D[i]
    
  }
  else {
    archae_data$Max_Hum_Head_D[i] <- NA
  } 
}

for (i in 1:nrow(archae_data)) {
  if (is.na(archae_data$L_Hum_Dist_Met_ML_D[i]) == FALSE){
    archae_data$Hum_Dist_Met_ML_D[i] <- archae_data$L_Hum_Dist_Met_ML_D[i]
    
  }
  else if (is.na(archae_data$L_Hum_Dist_Met_ML_D[i]) == TRUE & is.na(archae_data$R_Hum_Dist_Met_ML_D[i]) == FALSE){
    archae_data$Hum_Dist_Met_ML_D[i] <- archae_data$R_Hum_Dist_Met_ML_D[i]
    
  }
  else {
    archae_data$Hum_Dist_Met_ML_D[i] <- NA
  } 
}

archae_data$Hum_L <- as.numeric(as.character(archae_data$Hum_L))
archae_data$Hum_AP_Midshaft_D <- as.numeric(as.character(archae_data$Hum_AP_Midshaft_D))
archae_data$Hum_ML_Midshaft_D <- as.numeric(as.character(archae_data$Hum_ML_Midshaft_D))
archae_data$Hum_Max_L <- as.numeric(as.character(archae_data$Hum_Max_L))
archae_data$Hum_Dist_Met_ML_D <- as.numeric(as.character(archae_data$Hum_Dist_Met_ML_D))
archae_data$Max_Hum_Head_D <- as.numeric(as.character(archae_data$Max_Hum_Head_D))

```

For femur, similar processes were performed. However, since the side of the femur was indicated in another column. The following steps are cleaner.

```{r femur}

archae_data$Fem_Bio_L <- as.numeric(as.character(archae_data$Fem_Bio_L))
archae_data$Fem_Midshaft_AP_D <- as.numeric(as.character(archae_data$Fem_Midshaft_AP_D))
archae_data$Fem_Midshaft_ML_D <- as.numeric(as.character(archae_data$Fem_Midshaft_ML_D))
archae_data$Fem_Max_L <- as.numeric(as.character(archae_data$Fem_Max_L))
archae_data$Fem_Bicondylar_W <- as.numeric(as.character(archae_data$Fem_Bicondylar_W))
archae_data$Fem_Head_AP_D <- as.numeric(as.character(archae_data$Fem_Head_AP_D))
archae_data$Fem_Head_AP_D_E <- as.numeric(as.character(archae_data$Fem_Head_AP_D_E))


```

Same for tibia:

```{r tibia}

archae_data$Tib_Bio_L <- as.numeric(as.character(archae_data$Tib_Bio_L))
archae_data$Tib_Midshaft_AP_D <- as.numeric(as.character(archae_data$Tib_Midshaft_AP_D))
archae_data$Tib_Midshaft_ML_D <- as.numeric(as.character(archae_data$Tib_Midshaft_ML_D))
archae_data$Tib_Max_L <- as.numeric(as.character(archae_data$Tib_Max_L))
archae_data$Tib_Bicond_W <- as.numeric(as.character(archae_data$Tib_Bicond_W))
archae_data$Tib_Bicond_W_E <- as.numeric(as.character(archae_data$Tib_Bicond_W_E))
archae_data$Tib_Dist_Met_AP_D <- as.numeric(as.character(archae_data$Tib_Dist_Met_AP_D))
archae_data$Tib_Dist_Met_AP_D_E <- as.numeric(as.character(archae_data$Tib_Dist_Met_AP_D_E))
archae_data$Tib_Dist_Met_ML_D <- as.numeric(as.character(archae_data$Tib_Dist_Met_ML_D))
archae_data$Tib_Dist_Met_ML_D_E <- as.numeric(as.character(archae_data$Tib_Dist_Met_ML_D_E))

```

And finally for radius:

```{r radius}

archae_data$Rad_L <- as.numeric(as.character(archae_data$Rad_L))

```


# Mixed model approach to growth trajectories

## Plot growth trajectories of these bones

```{r plotting}
library(lattice)
library(scatterplot3d)
library(ggplot2)
library(RColorBrewer)
library(gridExtra)

# This is the trajectories of maximum femoral length
fem_l <- ggplot() +
  geom_point(aes(x = Age, y = Fem_Max_L, colour = Sample), alpha = 0.1, data = archae_data) +
  geom_smooth(aes(x = Age, y = Fem_Max_L, colour = Sample), se = FALSE, data = archae_data)

fem_bl <- ggplot() +
  geom_point(aes(x = Age, y = Fem_Bio_L, colour = Sample), alpha = 0.1, data = archae_data) +
  geom_smooth(aes(x = Age, y = Fem_Max_L, colour = Sample), se = FALSE, data = archae_data)


# This is the trajectories of femoral bicondylar width
fem_bi <- ggplot() +
  geom_point(aes(x = Age, y = Fem_Bicondylar_W, colour = Sample), alpha = 0.1, data = archae_data) +
  geom_smooth(aes(x = Age, y = Fem_Bicondylar_W, colour = Sample), se = FALSE, data = archae_data)

# This is the trajectories of femoral head diameter
fem_head <- ggplot() +
  geom_point(aes(x = Age, y = Fem_Head_AP_D, colour = Sample), alpha = 0.1, data = archae_data) +
  geom_smooth(aes(x = Age, y = Fem_Head_AP_D, colour = Sample), se = FALSE, data = archae_data) +
  geom_point(aes(x = Age, y = Fem_Head_AP_D_E, colour = Sample), alpha = 0.1, data = archae_data)

# This is the trajectories of femoral midshaft AP diameter
fem_midAP <- ggplot() +
  geom_point(aes(x = Age, y = Fem_Midshaft_AP_D, colour = Sample), alpha = 0.1, data = archae_data) +
  geom_smooth(aes(x = Age, y = Fem_Midshaft_AP_D, colour = Sample), se = FALSE, data = archae_data)

# This is the trajectories of femoral midshaft ML diameter
fem_midML <- ggplot() +
  geom_point(aes(x = Age, y = Fem_Midshaft_ML_D, colour = Sample), alpha = 0.1, data = archae_data) +
  geom_smooth(aes(x = Age, y = Fem_Midshaft_ML_D, colour = Sample), se = FALSE, data = archae_data) +
  geom_point(aes(x = Age, y = Fem_Midshaft_ML_D, colour = Sample), alpha = 0.1, data = archae_data)

grid.arrange(fem_l, fem_bl,
             fem_bi, fem_head, 
             fem_midAP, fem_midML,
             ncol = 2)

# Make a 3D plot
cloud(archae_data$Fem_Bicondylar_W ~ archae_data$Age*archae_data$Fem_Max_L|levels(archae_data$Sample),
      xlab = "Age", ylab = "Femur Max Length", zlab = "Femur Bicondylar Width",
      xlim = c(0, 17), ylim = c(70, 450), zlim = c(15, 85))

colors <- brewer.pal(7, "Set1")
colors <- colors[as.numeric(archae_data$Sample)]
scatterplot3d(x = archae_data$Age, y = archae_data$Fem_Max_L, z = archae_data$Fem_Bicondylar_W,
          xlab = "Age", ylab = "Femur Max Length", zlab = "Femur Bicondylar Width", angle = 100,
          color = colors, box = FALSE, pch = 16)

```

I understand none of these are very helpful so I will think of a way to present different trajectories through morphospace better...

## Body mass estimation

Use Ruff 2007 to estimate body mass. First write a function:

```{r body mass estimation functions, include=FALSE}

mass.estimation <- function(age, dfb, fhb){
               
  if (age >= 0 & age <= 1.4){
    wt = 0.188*dfb + 2.6
    return(c(wt, wt-2*0.65, wt+2*0.65))
  } else  if (age > 1.4 & age <= 2.4) {
    wt = 0.268*dfb + 0.2
    return(c(wt, wt-2*0.81, wt+2*0.81))
  } else  if (age > 2.4 & age <= 3.4) {
    wt = 0.257*dfb + 1.5
    return(c(wt, wt-2*0.91, wt+2*0.91))
  } else  if (age > 3.4 & age <= 4.4) {
    wt = 0.328*dfb - 0.7
    return(c(wt, wt-2*1.08, wt+2*1.08))
  } else  if (age > 4.4 & age <= 5.4) {
    wt = 0.367*dfb - 1.6
    return(c(wt, wt-2*1.08, wt+2*1.08))
  } else  if (age > 5.4 & age <= 6.4) {
    wt = 0.367*dfb - 0.4
    return(c(wt, wt-2*1.32, wt+2*1.32))
  } else  if (age > 6.4 & age <= 7.4) {
    if (is.na(fhb) == FALSE) {
    wt = 0.495*fhb - 8.0
    return(c(wt, wt-2*1.35, wt+2*1.35))}
    else { 
    wt = 0.419*dfb - 1.6
    return(c(wt, wt-2*1.38, wt+2*1.38))}
  } else  if (age > 7.4 & age <= 8.4) {
    if (is.na(fhb) == FALSE) {wt = 0.606*fhb - 6.1
    return(c(wt, wt-2*1.96, wt+2*1.96))}
    else {wt = 0.414*dfb + 0.5
    return(c(wt, wt-2*2.28, wt+2*2.28))}
  } else  if (age > 8.4 & age <= 9.4) {
    if (is.na(fhb) == FALSE) {wt = 1.155*fhb - 8.7
    return(c(wt, wt-2*3.52, wt+2*2.52))}
    else {wt = 0.694*dfb - 12.8
    return(c(wt, wt-2*4.44, wt+2*4.44))}
  } else  if (age > 9.4 & age <= 10.4) {
    if (is.na(fhb) == FALSE) {wt = 1.279*fhb - 12.2
    return(c(wt, wt-2*4.73, wt+2*4.73))}
    else {wt = 0.992*dfb - 29.5
    return(c(wt, wt-2*5.36, wt+2*5.36))}
  } else  if (age > 10.4 & age <= 11.4) {
    if (is.na(fhb) == FALSE) {wt = 1.626*fhb - 23.0
    return(c(wt, wt-2*5.61, wt+2*5.61))}
    else {wt = 0.938*dfb - 23.9
    return(c(wt, wt-2*6.84, wt+2*6.84))}
  } else  if (age > 11.4 & age <= 12.4) {
    if (is.na(fhb) == FALSE) {wt = 1.850*fhb - 31.3
    return(c(wt, wt-2*5.65, wt+2*5.65))}
    else {wt = 1.351*dfb - 49.6
    return(c(wt, wt-2*7.38, wt+2*7.38))}
  } else  if (age > 12.4 & age <= 13.4) {
    wt = 1.830*fhb - 29.4
    return(c(wt, wt-2*7.84, wt+2*7.84))
  } else  if (age > 13.4 & age <= 14.4) {
    wt = 1.438*fhb - 10.3
    return(c(wt, wt-2*7.75, wt+2*7.75))
  }  else  if (age > 14.4 & age <= 15.4) {
    wt = NA
    return(c(wt, wt, wt))
  }  else  if (age > 15.4 & age <= 16.4) {
    wt = 1.009*(0.842*log(fhb) + 0.88)
    return(c(wt, wt-2*6.03, wt+2*6.03))
  } else  if (age > 16.4 & age <= 17.4) {
    wt = 1.750*fhb - 17.2
    return(c(wt, wt-2*7.34, wt+2*7.34))
  } else {}

}

```

Then use that fuction on our data set:

```{r estimat body mass}

archae_data$Wt <- NA
archae_data$Wt_low <- NA
archae_data$Wt_high <- NA
for (i in 1:nrow(archae_data)) {
  
  archae_data[i,c("Wt", "Wt_low", "Wt_high")] <- mass.estimation(archae_data$Age[i], archae_data$Fem_Bicondylar_W[i], archae_data$Fem_Head_AP_D[i])
  
}

head(archae_data[, c("Wt", "Wt_low", "Wt_high")], n = 5)
```


## Subset data for each bone, add ecological variables into said data set

```{r subset and make new data.frame}
# Subset femur and tibia first:

femur <- as.data.frame(cbind(as.character(archae_data$Sample), archae_data$Number, archae_data$Age, 
                             archae_data$Fem_Bio_L, archae_data$Fem_Max_L, 
                             archae_data$Fem_Head_AP_D, archae_data$Fem_Head_AP_D_E,
                             archae_data$Fem_Midshaft_AP_D, archae_data$Fem_Midshaft_ML_D,  
                             archae_data$Fem_Bicondylar_W,
                             archae_data$Wt, archae_data$Wt_low, archae_data$Wt_high))

names(femur) <- c("Sample", "ID", "Age", "Fem_BioL", "Fem_MaxL", "Fem_HD", "Fem_HD_E",
                  "Fem_MidAP", "Fem_MidML", "Fem_DW", "Wt", "Wt_low", "Wt_high") 

# Change data type to numeric instead of factor
femur$Age <- as.numeric(as.character(femur$Age))
femur$Fem_BioL <- as.numeric(as.character(femur$Fem_BioL))
femur$Fem_MaxL <- as.numeric(as.character(femur$Fem_MaxL))
femur$Fem_HD <- as.numeric(as.character(femur$Fem_HD))
femur$Fem_HD_E <- as.numeric(as.character(femur$Fem_HD_E))
femur$Fem_MidAP <- as.numeric(as.character(femur$Fem_MidAP))
femur$Fem_MidML <- as.numeric(as.character(femur$Fem_MidML))
femur$Fem_DW <- as.numeric(as.character(femur$Fem_DW))
femur$Wt <- as.numeric(as.character(femur$Wt))
femur$Wt_low <- as.numeric(as.character(femur$Wt_low))
femur$Wt_high <- as.numeric(as.character(femur$Wt_high))

# Check the data set
head(femur, n = 5)

for (i in 1:nrow(femur)) {
  if (is.na(femur$Fem_HD[i])== TRUE && is.na(femur$Fem_HD_E[i]) == FALSE){
      
    femur$Fem_HD[i] <- femur$Fem_HD_E[i]  
  }
}



tibia <- as.data.frame(cbind(as.character(archae_data$Sample), archae_data$Number, archae_data$Age,
                             archae_data$Tib_Bio_L,
                       archae_data$Tib_Max_L, archae_data$Tib_Max_L_E, archae_data$Tib_Bicond_W,
                       archae_data$Tib_Bicond_W_E, archae_data$Tib_Midshaft_AP_D, archae_data$Tib_Midshaft_ML_D,
                       archae_data$Tib_Dist_Met_ML_D, archae_data$Tib_Dist_Met_ML_D_E, archae_data$Tib_Dist_Met_AP_D,
                       archae_data$Tib_Dist_Met_AP_D_E,
                       archae_data$Wt, archae_data$Wt_low, archae_data$Wt_high))

names(tibia) <- c("Sample", "ID", "Age", "Tib_BioL", "Tib_MaxL", "Tib_MaxL_E", "Tib_PW", "Tib_PW_E",
                  "Tib_MidAP", "Tib_MidML", "Tib_DML", "Tib_DML_E", "Tib_DAP", "Tib_DAP_E",
                  "Wt", "Wt_low", "Wt_high") 

tibia$Age <- as.numeric(as.character(tibia$Age))
tibia$Tib_BioL <- as.numeric(as.character(tibia$Tib_BioL))
tibia$Tib_MaxL <- as.numeric(as.character(tibia$Tib_MaxL))
tibia$Tib_MaxL_E <- as.numeric(as.character(tibia$Tib_MaxL_E))
tibia$Tib_PW <- as.numeric(as.character(tibia$Tib_PW))
tibia$Tib_PW_E <- as.numeric(as.character(tibia$Tib_PW_E))
tibia$Tib_MidAP <- as.numeric(as.character(tibia$Tib_MidAP))
tibia$Tib_MidML <- as.numeric(as.character(tibia$Tib_MidML))
tibia$Tib_DML <- as.numeric(as.character(tibia$Tib_DML))
tibia$Tib_DML_E <- as.numeric(as.character(tibia$Tib_DML_E))
tibia$Tib_DAP <- as.numeric(as.character(tibia$Tib_DAP))
tibia$Tib_DAP_E <- as.numeric(as.character(tibia$Tib_DAP_E))
tibia$Wt <- as.numeric(as.character(tibia$Wt))
tibia$Wt_low <- as.numeric(as.character(tibia$Wt_low))
tibia$Wt_high <- as.numeric(as.character(tibia$Wt_high))

head(tibia, n = 5)

for (i in 1:nrow(tibia)) {
  if (is.na(tibia$Tib_MaxL[i])== TRUE && is.na(tibia$Tib_MaxL_E[i]) == FALSE){
      
    tibia$Tib_MaxL[i] <- tibia$Tib_MaxL_E[i]  
  }
}

for (i in 1:nrow(tibia)) {
  if (is.na(tibia$Tib_PW[i])== TRUE && is.na(tibia$Tib_PW_E[i]) == FALSE){
      
    tibia$Tib_PW[i] <- tibia$Tib_PW_E[i]  
  }
}

for (i in 1:nrow(tibia)) {
  if (is.na(tibia$Tib_DML[i])== TRUE && is.na(tibia$Tib_DML_E[i]) == FALSE){
      
    tibia$Tib_DML[i] <- tibia$Tib_DML_E[i]  
  }
}

for (i in 1:nrow(tibia)) {
  if (is.na(tibia$Tib_DAP[i])== TRUE && is.na(tibia$Tib_DAP_E[i]) == FALSE){
      
    tibia$Tib_DAP[i] <- tibia$Tib_DAP_E[i]  
  }
}


# Create new variable: lifestyle
lifestyle <- as.data.frame(matrix(c("Cal Amerindian", "Hunter-gatherer",
        "Indian Knoll", "Hunter-gatherer",
        "Kulubnarti", "Agriculturalist",
        "Mistihalj", "Agriculturalist",
        "Dart", "Industrialized",
        "Luis Lopes", "Industrialized",
        "Point Hope", "Hunter-gatherer"), ncol = 2, byrow = TRUE))

# Creating new variables: temperatures
eco.variable <- as.data.frame(matrix(c("Cal Amerindian", 8.65, 22.05, 0.1,
                                       "Indian Knoll", 10.6, 35.5, -5.4,
                                       "Kulubnarti", 26.5, 42.1, 9.1,
                                       "Mistihalj", 7.4, 23.4, -8.9,
                                       "Dart", 14.4, 25.2, -0.5,
                                       "Luis Lopes", 16.2, 24.9, 9.2,
                                       "Point Hope", -6.6, 8.4, -21.3), ncol = 4, byrow = TRUE))

eco.variable[,2] <- as.numeric(as.character(eco.variable[,2]))
eco.variable[,3] <- as.numeric(as.character(eco.variable[,3]))
eco.variable[,4] <- as.numeric(as.character(eco.variable[,4]))

names(lifestyle) <- c("Sample", "Lifestyle")
names(eco.variable) <- c("Sample", "Ann.Temp", "Warm.Temp", "Cold.Temp")

femur <- merge(femur, lifestyle, by = "Sample")
femur <- merge(femur, eco.variable, by = "Sample")

tibia <- merge(tibia, lifestyle, by = "Sample")
tibia <- merge(tibia, eco.variable, by = "Sample")

head(femur, n = 5)
head(tibia, n = 5)
```


## Set up for mixed modeling
```{r required functions, include=FALSE}
distance.overland <- function(geoinfo)
{
  # SUPPORT FUNCTIONS
  
  # Km between two pointson the globe using the haversine. 
  geodist.hav <- function(loc1, loc2)
  { 
    ct <- pi/180 
    radius <- 6371
    
    #the latitudes and longitudes
    lat1 <- loc1[1]
    lon1 <- loc1[2]
    lat2 <- loc2[1]
    lon2 <- loc2[2]
    
    a <- sin( ((lat2 - lat1)*ct)/2)^2 +
      cos(lat1*ct) * cos(lat2*ct) * sin(((lon2 - lon1)*ct)/2)^2 
    c <- 2 * asin(min(1,sqrt(a)))
    d <- radius * c
  }
  
  
  # distances for interwaypoint travel, passing through other waypoints
  # where sensible. 
  interway.km <- function(waypoints, waypassage)
  {
    interway.dist <- rep(0,nrow(waypassage))
    # number of waypoints for each possible pair
    nlinks <-  rowSums(!is.na(waypassage))
    
    for(i in 1:nrow(waypassage))
    {
      #with one or fewer links, interway.dist = 0
      if(nlinks[i]==0|1) {interway.dist[i] <- 0}
      
      #with 2 or more links, interway.dist is calculated jump by jump
      if(nlinks[i]>1) {
        link.vec <- waypassage[i, which(!is.na(waypassage[i,]))]
        link.dists <- rep(0, length(link.vec)-1)
        
        for(j in 1:length(link.dists))
        {
          #calculate distance for each link
          way1 <- waypoints[which(rownames(waypoints)==names(link.vec[which(link.vec==j)])),]
          way2 <- waypoints[which(rownames(waypoints)==names(link.vec[which(link.vec==j+1)])),]
          link.dists[j] <- geodist.hav(way1, way2)
        }
        interway.dist[i] <- sum(link.dists)
        names(interway.dist) <- rownames(waypassage)
      }}
    
    interway <- data.frame(wayStartEnd=paste(region.clust, region.seq, sep=""),
                           wayPoints=nlinks, wayKm=interway.dist)
  }
  
  ############################################################
  
  # SUPPORT DATA (values do not depend on geoinfo)
  
  # waypoints: matrix of waypoints w/ latitude and longitude
  Cairo <- c(30, 31)
  Istanbul <- c(41, 29)
  PhnomPenh <- c(11.5, 105)
  Anadyr <- c(64.5, 177.5)
#  PrinceRupert <- c(54.5, -130.5)
  Nome <- c(64.5088, -165.4073)
  MexicoCity <- c(19.5, -99)
  waypoints <- rbind(Cairo, Istanbul, PhnomPenh, Anadyr, Nome, MexicoCity)
  colnames(waypoints) <- c("lat", "long")
  
  # waypassage: for all possible pairs of interregional travel, the waypoints
  regions <- c("Africa", "MidEast", "Asia", "Europe", "Oceania", "NAmerica", "SAmerica")
  region.seq <- rep(regions, 7)
  region.clust <- rep(regions, each=7)
  waypassage.rownames  <- paste(region.clust, region.seq, sep=" > ")
  waypassage <- matrix(NA, nrow=length(waypassage.rownames), ncol=nrow(waypoints))
  rownames(waypassage) <- waypassage.rownames
  colnames(waypassage) <- rownames(waypoints)
  
  #Africa endpoints, in order
  waypassage[2:7,1] <- 1
  waypassage[4,2] <- 2
  waypassage[5,3] <- 2
  waypassage[6:7,4] <- 2
  waypassage[6:7, 5] <- 3
  waypassage[7,6] <- 4
  waypassage[1:7,]
  #Middle East endpoints (no waypoints between Asia)
  waypassage[8,1] <- waypassage[11,2]<- waypassage[12,3] <- 1 
  waypassage[13,] <- c(NA, NA, NA, 1, 2, NA)
  waypassage[14,] <- c(NA, NA, NA, 1, 2, 3)
  #Asia enpoints
  waypassage[15,1] <- waypassage[18,2] <- waypassage[19,3] <- 1
  waypassage[20,] <- c(NA, NA, NA, 1, 2, NA)
  waypassage[21,] <- c(NA, NA, NA, 1, 2, 3)
  #Europe enpoints
  waypassage[22,1:2] <- c(2,1)
  waypassage[23,2] <- waypassage[24,2] <- 1
  waypassage[26, 2:3] <- c(1,2)
  waypassage[27,] <- c(NA, 1, NA, 2, 3, NA)
  waypassage[28,] <- c(NA, 1, NA, 2, 3, 4)
  #Oceania endpoints
  waypassage[c(29:32, 34:35), 3] <- 1
  waypassage[29,1] <- waypassage[32,2] <- waypassage[34:35, 4] <- 2
  waypassage[34:35,5] <- 3
  waypassage[35, 6] <- 4
  #North America endpoints
  waypassage[36:40,5] <- 1
  waypassage[36:40,4] <- 2
  waypassage[36,1] <- waypassage[39,2] <- waypassage[40,3] <- 3
  waypassage[42,6] <- 1
  #South America endpoints
  waypassage[43,] <- waypassage[44,] <- waypassage[45,] <-
  waypassage[46,] <- waypassage[47,] <- c(NA, NA, NA, 3, 2, 1)
  waypassage[43,1] <- waypassage[46, 2] <- waypassage[47,3] <- 4
  waypassage[48,6] <- 1
  
  # ways.regions: for all possible regional jumps, the first and last waypoint
  single.way.rows <- which(rowSums(waypassage, na.rm=TRUE)==1)
  single.ways <- waypassage[single.way.rows,]
  start.ends <- paste(region.clust, region.seq, sep="")[single.way.rows]
  single.waypoints <- data.frame(waypoint=apply(single.ways, 1, function(x) names(which(x==1))),
                                 StartEnd=start.ends)
  rownames(single.waypoints) <- names(single.ways)
  
  with.way.rows <- which(apply(!is.na(waypassage), 1, any)==TRUE)
  with.way <- waypassage[with.way.rows,]
  with.way[is.na(with.way)]<- 0
  first.way <- apply(with.way, 1, function(x) names(which(x==1)))
  last.way <- apply(with.way, 1, function(x) names(which(x==max(x))))
  start.ends <- paste(region.clust, region.seq, sep="")[with.way.rows]
  ways.regions <- data.frame(firstWay=first.way, lastWay=last.way,
                             StartEnd=start.ends)
  rownames(ways.regions) <- names(single.ways)
  
  #for multiwaypoint travel, the distance between the first and last waypoint
  interway.distances <- interway.km(waypoints,waypassage)
  
  #####################################################################
  
  # FUNCTION OPERATIONS (values depend on geoinfo)
  
  # latlongs: data frame of latitudes, longitudes, and regions for sampled groups
  rownames(geoinfo) <- geoinfo[,3]
  latlongs <- data.frame(lat=geoinfo[,1], long=geoinfo[,2],
                         Region=geoinfo[,4])
  latlongnames <- as.character(geoinfo[,3])
  rownames(latlongs) <- latlongnames
  
  # geodists: total distance between pop pairs is the sum of the columns
  pairwise.region.mat <- matrix(NA, nrow(latlongs), nrow(latlongs))
  rownames(pairwise.region.mat)<-colnames(pairwise.region.mat) <- rownames(latlongs)
  pop.clust <- rep(rownames(latlongs), nrow(latlongs))
  pop.seq <- rep(rownames(latlongs), each=nrow(latlongs))
  Reg12 <- paste(rep(latlongs$Region, nrow(latlongs)), 
                 rep(latlongs$Region, each=nrow(latlongs)), sep="")
  
  
  wayPts <- interway.distances$wayPoints[match(Reg12, interway.distances$wayStartEnd)]
  pops.regs.ways <- data.frame(Pop1=pop.clust, Pop2=pop.seq, Reg12=Reg12, 
                               wayPts = wayPts)
  
  geodists <- matrix(NA, nrow(pops.regs.ways), ncol=4)
  colnames(geodists) <- c("wayKm", "toWayA", "toWayB", "Pop2Pop")
  rownames(geodists) <- 
    paste(pops.regs.ways$Pop1, pops.regs.ways$Pop2, sep=" > ")
  geodists[,1] <- 
    interway.distances$wayKm[match(Reg12, 
                                   interway.distances$wayStartEnd)]
  
  for(i in 1:nrow(geodists))
  {
    PopA <- pops.regs.ways$Pop1[i]
    latlongA <- as.numeric(latlongs[which(rownames(latlongs)==PopA),1:2])
    PopB <- pops.regs.ways$Pop2[i]
    latlongB <- as.numeric(latlongs[which(rownames(latlongs)==PopB),1:2])
    
    if(pops.regs.ways$wayPts[i]==0) {
      #toWayA
      geodists[i,2] <- 0 
      #toWayB
      geodists[i,3] <- 0
      #Pop2Pop
      geodists[i,4] <- geodist.hav(latlongA,latlongB)
    }
    
    if(pops.regs.ways$wayPts[i] > 0) {
      waypoints.row <- match(pops.regs.ways$Reg12[i], 
                             ways.regions$StartEnd)
      wayA <- ways.regions$firstWay[waypoints.row]
      wayB <- ways.regions$lastWay[waypoints.row]
      wayA.latlong <- waypoints[which(rownames(waypoints)==wayA),]
      wayB.latlong <- waypoints[which(rownames(waypoints)==wayB),]
      geodists[i,2] <- geodist.hav(latlongA, wayA.latlong) 
      geodists[i,3] <- geodist.hav(latlongB, wayB.latlong) 
      geodists[i,4] <- 0
    }
  }
  
  # convert to pairwise distance matrix
  pw.dists <- matrix(apply(geodists, 1, sum), 
                     nrow=nrow(latlongs), ncol=nrow(latlongs))
  rownames(pw.dists) <- colnames(pw.dists) <- rownames(latlongs)
  
  return(pw.dists)
}

#Dmax.Amatrix

#calculates the relationship matrix directly from delta mu squared.

Dmax.Amatrix <- function(dist.mat){
  Dmax <- max(dist.mat)
  A.matrix <- (Dmax-dist.mat)/Dmax
  return(A.matrix)  
}

#the expected correlation between groups i and j can be expressed as 
#the difference between the maximum distance between two groups in the 
#sample minus the distance between groups i and j (pw.dmu[i,j]), divided
#by the maximum distance between two groups in the sample
```


First, we need a population relationship matrix. To do that, we need a matrix of distances between populations.

```{r mixed model set up}
#ThankyouDavid #Youarethebest

# This is the input format for David's function
arch_pop <- as.data.frame(matrix(c(40.80, -123.80, "Cal Amerindian", "NAmerica",
         37.268, -86.984, "Indian Knoll", "NAmerica",
         21.070, 30.665, "Kulubnarti", "Africa",
         43.704, 19.396, "Mistihalj", "Europe",
         -26.188, 28.025, "Dart", "Africa",
         38.717, -9.133, "Luis Lopes", "Europe",
         68.341, -166.758, "Point Hope", "NAmerica"), ncol = 4, byrow = TRUE))

arch_pop[,1] <- as.numeric(as.character(arch_pop[,1]))
arch_pop[,2] <- as.numeric(as.character(arch_pop[,2]))
names(arch_pop) <- c("Latitude", "Longitude", "Pop", "Region")

# Save a csv file for these data for the future
write.csv(arch_pop, file = "arch_pop_info.csv", row.names = FALSE)

# Use distance.overland function to calculate a matrix of geographic distances
# This function is available at https://gist.github.com/davidckatz
dist.mat <- distance.overland(arch_pop)
dist.mat

# Once we have our geographic distances, use the following regression coefficients to get the estimated delta mus
# These coefficients are based on regression of genetic distances (CEPH database) on geographic distances
my.int <- 4.5466402644      
my.beta <- 0.0008127043

# Predict delta mu squared with linear regression
linear.dmu <- my.int + (my.beta * dist.mat)
diag(linear.dmu) <- 0
#pred.dmu.distmat <- as.dist(linear.dmu)
# CALCULATE RELATIONSHIP (A) MATRIX BASED ON PAIRWISE DELTA-MU VALUES
# This function is also available at https://gist.github.com/davidckatz
Amat.linear <- Dmax.Amatrix(linear.dmu)

```

The A matrix is analogous to relationship matrix used in phylogenetic analysis. The elements Aij in the A matrix are equal to the length of the path from the most recent common ancestor of species i and j to the root of the phylogeny. ( _Reference:_ Hadfield, J. D., & Nakagawa, S. (2010). General quantitative genetic methods for comparative biology: phylogenies, taxonomies and multi‐trait models for continuous and categorical characters. *Journal of evolutionary biology*, 23(3), 494-508.)

Since we populate the A matrix __*directly*__, we are now ready to conduct the mixed model analysis.

## Mixed model analysis usig `brms` package

*Reference:* Bürkner, P. C. (2017). brms: An R package for Bayesian multilevel models using Stan. *Journal of Statistical Software*, 80(1), 1-28.

I am using `brms` package instead of `MCMCglmm` package because it is more flexible in model building and variable selection. The syntax is similar to `lme4` package, which allows me to specify **both** random intercept and random slope (this will hopefully be useful when we're ready to publish).

*Reference:* Bürkner, P. C. (2017). Advanced Bayesian multilevel modeling with the R package brms. *arXiv preprint arXiv:1705.11123.*

First I want to fit a null model, which is just a multivariate linear model:

$\mathbf{Y} = \mathbf{X}\beta + \epsilon$

```{r null model}
# So I need to deal missing values first.
# (Still wondering what is the best approach here)
library(mice)
library(brms)
library(rstan)

# This is using Bayesian linear model to deal with missing data
# I am using the default setting to generate 4 MCMC chains, each with 2000 iterations and 1000 burn-in
# Consider changing this later
# It took a while to run
# So maybe impute missing values first and then just do a lm is a better approach? Discuss.
femur.null <- brm(mvbind(Fem_MaxL, Fem_HD, Fem_MidAP, Fem_MidML, Fem_DW) ~ Age + Wt + Lifestyle +
                   Ann.Temp + Warm.Temp + Cold.Temp, data = femur)


tibia.null <- brm(mvbind(Tib_MaxL, Tib_PW, Tib_MidAP, Tib_MidML, Tib_DML, Tib_DAP) ~ Age + Wt + Lifestyle +
                   Ann.Temp + Warm.Temp + Cold.Temp, data = tibia)

```

And to get the summary output:
```{r outut from the null model}
summary(femur.null)

# Plot fitted regression line against real data
# Extract all the variables from previous data sets
predicted <- data.frame(cbind(as.character(archae_data$Sample), archae_data$Age, archae_data$Wt))
names(predicted) <- c("Sample", "Age", "Wt")
predicted <- merge(predicted, eco.variable, by = "Sample")
predicted <- merge(predicted, lifestyle, by = "Sample")
predicted$Age <- as.numeric(as.character(predicted$Age))
predicted$Wt <- as.numeric(as.character(predicted$Wt))

predicted.femur.null <- predict(femur.null, newdata = predicted)
predicted.femur.null <- as.data.frame(predicted.femur.null)
predicted.femur.null <- cbind(predicted, predicted.femur.null)

ggplot() +
  geom_smooth(aes(x = Age, y = Estimate.FemMaxL, colour = Sample), method = "lm",
              se = FALSE, data = predicted.femur.null) +
  geom_line(stat = "smooth", method = "loess", aes(x = Age, y = Fem_MaxL, colour = Sample), 
            se = FALSE, data = femur, alpha = 0.5, linetype = "dashed", size = 1.5) +
  ylab("Femur diaphyseal length") +
  xlab("Age")

ggplot() +
  geom_smooth(aes(x = Age, y = Estimate.FemHD, colour = Sample), method = "lm",
              se = FALSE, data = predicted.femur.null) +
  geom_line(stat = "smooth", method = "loess", aes(x = Age, y = Fem_HD, colour = Sample), 
            se = FALSE, data = femur, alpha = 0.5, linetype = "dashed", size = 1.5) +
  ylab("Femoral head diameter") +
  xlab("Age")

ggplot() +
  geom_smooth(aes(x = Age, y = Estimate.FemDW, colour = Sample), method = "lm",
              se = FALSE, data = predicted.femur.null) +
  geom_line(stat = "smooth", method = "loess", aes(x = Age, y = Fem_DW, colour = Sample), 
            se = FALSE, data = femur, alpha = 0.5, linetype = "dashed", size = 1.5) +
  ylab("Femur distal breadth") +
  xlab("Age")


# So our null model apparently didn't fit the model well
# Distal width of the femur has the worst fit out of the three I plotted here

summary(tibia.null)

predicted.tibia.null <- predict(tibia.null, newdata = predicted)
predicted.tibia.null <- as.data.frame(predicted.tibia.null)
predicted.tibia.null <- cbind(predicted, predicted.tibia.null)

ggplot() +
  geom_smooth(aes(x = Age, y = Estimate.TibMaxL, colour = Sample), method = "lm",
              se = FALSE, data = predicted.tibia.null) +
  geom_line(stat = "smooth", method = "loess", aes(x = Age, y = Tib_MaxL, colour = Sample), 
            se = FALSE, data = tibia, alpha = 0.5, linetype = "dashed", size = 1.5) +
  ylab("Tibia diaphyseal length") +
  xlab("Age")

ggplot() +
  geom_smooth(aes(x = Age, y = Estimate.TibPW, colour = Sample), method = "lm",
              se = FALSE, data = predicted.tibia.null) +
  geom_line(stat = "smooth", method = "loess", aes(x = Age, y = Tib_PW, colour = Sample), 
            se = FALSE, data = tibia, alpha = 0.5, linetype = "dashed", size = 1.5) +
  ylab("Tibia proximal breadth") +
  xlab("Age")

ggplot() +
  geom_smooth(aes(x = Age, y = Estimate.TibDML, colour = Sample), method = "lm",
              se = FALSE, data = predicted.tibia.null) +
  geom_line(stat = "smooth", method = "loess", aes(x = Age, y = Tib_DML, colour = Sample), 
            se = FALSE, data = tibia, alpha = 0.5, linetype = "dashed", size = 1.5) +
  ylab("Tibia distal breadth") +
  xlab("Age")

# Same thing with tibia, very poor fit

```


Then let's try to fit a model with random effects (population structure). So it has two levels: population-level and individual level
**Level 1:** $Y = \beta_{0} + X_{i}\beta_{i} + \epsilon$
**Level 2:** $\beta_{0} = Z_{i}\mu_{i}$

```{r mixed model 1 - no climatic variable}
# So this model will NOT have climatic variables as predictor

# Multivariate response variables: all femur measurements
# Fixed effects: age, body mass, lifestyle (categorical variable)
# Random effects: population structure. I am only modeling intercept as random here (so each population will have a different intercept, which is distributed with some variance)
# This is the same as MCMCglmm (I think)
# (This model will take a while to run)
femur.no.climate <- brm(mvbind(Fem_MaxL, Fem_HD, Fem_MidAP, Fem_MidML, Fem_DW) ~ Age + Wt + Lifestyle +
                          (1|2|Sample), data = femur, cov_ranef = list(Sample = Amat.linear), control = list(adapt_delta = 0.99))


summary(femur.no.climate)

# Posterior predictive check
layout(matrix(c(1, 1,
                2, 3,
                4, 5), 2, 3, byrow = TRUE))
pp_check(femur.no.climate, resp = "FemMaxL")
pp_check(femur.no.climate, resp = "FemHD")
pp_check(femur.no.climate, resp = "FemMidAP")
pp_check(femur.no.climate, resp = "FemMidML")
pp_check(femur.no.climate, resp = "FemDW")

# So it looks like midshaft AP diameter is really poorly predicted based on our model parameters

# Fit the model to the data to get the fitted line
predicted.femur.no.climate <- predict(femur.no.climate, newdata = predicted)
predicted.femur.no.climate <- as.data.frame(predicted.femur.no.climate)
predicted.femur.no.climate <- cbind(predicted, predicted.femur.no.climate)

# Plot the fitted line
ggplot() +
  geom_smooth(aes(x = Age, y = Estimate.FemMaxL, colour = Sample), method = "loess",
              se = FALSE, data = predicted.femur.no.climate) +
  geom_line(stat = "smooth", method = "loess", aes(x = Age, y = Fem_MaxL, colour = Sample), 
            se = FALSE, data = femur, alpha = 0.5, linetype = "dashed", size = 1.5) +
  ylab("Femur diaphyseal length") +
  xlab("Age")

ggplot() +
  geom_smooth(aes(x = Age, y = Estimate.FemHD, colour = Sample), method = "loess",
              se = FALSE, data = predicted.femur.no.climate) +
  geom_line(stat = "smooth", method = "loess", aes(x = Age, y = Fem_HD, colour = Sample), 
            se = FALSE, data = femur, alpha = 0.5, linetype = "dashed", size = 1.5) +
  ylab("Femoral head diameter") +
  xlab("Age")

ggplot() +
  geom_smooth(aes(x = Age, y = Estimate.FemDW, colour = Sample), method = "loess",
              se = FALSE, data = predicted.femur.no.climate) +
  geom_line(stat = "smooth", method = "loess", aes(x = Age, y = Fem_DW, colour = Sample), 
            se = FALSE, data = femur, alpha = 0.5, linetype = "dashed", size = 1.5) +
  ylab("Femur distal breadth") +
  xlab("Age")


# We can do the same with tibia measurements:
tibia.no.climate <- brm(mvbind(Tib_MaxL, Tib_PW, Tib_MidAP, Tib_MidML, Tib_DML + Tib_DAP) ~ Age + Wt + Lifestyle +
                          (1|2|Sample), data = tibia, cov_ranef = list(Sample = Amat.linear), control = list(adapt_delta = 0.99))

summary(tibia.no.climate)

layout(matrix(c(1, 2,
                3, 4,
                5, 6), 2, 3, byrow = TRUE))
pp_check(tibia.no.climate, resp = "TibMaxL")
pp_check(tibia.no.climate, resp = "TibPW")
pp_check(tibia.no.climate, resp = "TibMidAP")
pp_check(tibia.no.climate, resp = "TibMidML")
pp_check(tibia.no.climate, resp = "TibDML")
pp_check(tibia.no.climate, resp = "TibDAP")

```

Now fit the second mixed model (third overall), this time I will include BOTH climatic variables and 

```{r mixed model 2 - climatic variables}

# Multivariate response variables: all femur measurements
# Fixed effects: age, body mass, lifestyle (categorical variable) + all climatic variables (temperature)
# Random effects: population structure.
# (This model will take a while to run)

femur.all <- brm(mvbind(Fem_MaxL, Fem_HD, Fem_MidAP, Fem_MidML, Fem_DW) ~ Age + Wt + Lifestyle + Ann.Temp +
                   Warm.Temp + Cold.Temp + (1|2|Sample), data = femur, cov_ranef = list(Sample = Amat.linear), 
                 control = list(adapt_delta = 0.99))

summary(femur.all)

layout(matrix(c(1, 1,
                2, 3,
                4, 5), 2, 3, byrow = TRUE))
pp_check(femur.all, resp = "FemMaxL")
pp_check(femur.all, resp = "FemHD")
pp_check(femur.all, resp = "FemMidAP")
pp_check(femur.all, resp = "FemMidML")
pp_check(femur.all, resp = "FemDW")

tibia.all <- brm(mvbind(Tib_MaxL, Tib_PW, Tib_MidAP, Tib_MidML, Tib_DML + Tib_DAP) ~ Age + Wt + Lifestyle +
                   Ann.Temp + Warm.Temp + Cold.Temp + (1|2|Sample), 
                 data = tibia, cov_ranef = list(Sample = Amat.linear), control = list(adapt_delta = 0.99))

summary(tibia.all)

# Fit the model to the data to get the fitted line
predicted.femur.all <- predict(femur.all, newdata = predicted)
predicted.femur.all <- as.data.frame(predicted.femur.all)
predicted.femur.all <- cbind(predicted, predicted.femur.all)

# Plot the fitted line
ggplot() +
  geom_smooth(aes(x = Age, y = Estimate.FemMaxL, colour = Sample), method = "loess",
              se = FALSE, data = predicted.femur.all) +
  geom_line(stat = "smooth", method = "loess", aes(x = Age, y = Fem_MaxL, colour = Sample), 
            se = FALSE, data = femur, alpha = 0.5, linetype = "dashed", size = 1.5) +
  ylab("Femur diaphyseal length") +
  xlab("Age")

ggplot() +
  geom_smooth(aes(x = Age, y = Estimate.FemHD, colour = Sample), method = "loess",
              se = FALSE, data = predicted.femur.all) +
  geom_line(stat = "smooth", method = "loess", aes(x = Age, y = Fem_HD, colour = Sample), 
            se = FALSE, data = femur, alpha = 0.5, linetype = "dashed", size = 1.5) +
  ylab("Femoral head diameter") +
  xlab("Age")

ggplot() +
  geom_smooth(aes(x = Age, y = Estimate.FemDW, colour = Sample), method = "loess",
              se = FALSE, data = predicted.femur.all) +
  geom_line(stat = "smooth", method = "loess", aes(x = Age, y = Fem_DW, colour = Sample), 
            se = FALSE, data = femur, alpha = 0.5, linetype = "dashed", size = 1.5) +
  ylab("Femur distal breadth") +
  xlab("Age")

layout(matrix(c(1, 2,
                3, 4,
                5, 6), 2, 3, byrow = TRUE))
pp_check(tibia.all, resp = "TibMaxL")
pp_check(tibia.all, resp = "TibPW")
pp_check(tibia.all, resp = "TibMidAP")
pp_check(tibia.all, resp = "TibMidML")
pp_check(tibia.all, resp = "TibDML")
pp_check(tibia.all, resp = "TibDAP")
```

After fitting all three models, there are some follow up analyses that need to be done. These include model comparison and variable selection. First we start by doing a model comparison between the three models:
